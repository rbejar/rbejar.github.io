<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">  
  <title>Arquitectura de software: una perspectiva ágil</title>
  <link rel="stylesheet" type="text/css" href="focalizejs-style.css">
  <link rel="stylesheet" type="text/css" href="simple-city-style/simple-city-style.css">
      
  <script src="lib/jquery-2.0.3.js"></script>
  <script src='lib/jquery.transit.js'></script>
  <script src="lib/jquery.fullscreen-0.3.5.js"></script>     
  <script src="lib/textFit.js"></script>  
  <script src="lib/motio.js"></script>   
  <script src="lib/jquery.hammer.js"></script> <!-- v1.05; v1.06dev does not work -->
  <script src="src/Focalize.js"></script>
  <script src="simple-city-style/simple-city-style.js"></script>  
  <script>Focalize.load();</script>
</head>
<body>

<div class="focalize-presentation">
  <div class="focalize-sequence" data-seq-name="SimpleCitySequence1">
   	<section class="focalize-slide" data-slide-name="SimpleCitySlide1_NoTitle">    
          <h2>Arquitectura de software</h2>
          <h3>Una perspectiva ágil</h3>
          <h2>    </h2><!-- Create some space-->
          <h2>    </h2><!-- Create some space-->
          <h4>Salvo que se indique lo contrario, este trabajo es (c) 2015 <a href="http://www.rubenbejar.com/" target="_blank">Rubén Béjar</a>, bajo una <a href="https://creativecommons.org/licenses/by-sa/3.0/es/" target="_blank">licencia Creative Commons Reconocimiento-CompartirIgual 3.0 España</a></h4>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Arquitectura de Software</h1>
          <h2>La arquitectura de un sistema es su organización fundamental, plasmada en sus componentes, sus relaciones (entre ellos y con el entorno) y los principios que guían su diseño y evolución</h2>
          <h4>IEEE Architecture Working Group. IEEE Recommended Practice for Architectural Description of Software-Intensive Systems. IEEE Standard IEEE Std 1471-2000, IEEE Standards Association, 2000</h4>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Arquitectura de Software. ¿Para qué?</h1>
          <h2>Las decisiones arquitecturales son las que permiten que el sistema cumpla sus requisitos de calidad y de comportamiento</h2>		  
		  <h4>Clements, P., Bachmann, F., Bass, L., Garlan, D., Ivers, J., Little, R., Merson, P., Nord, R., and Stafford, J. Documenting Software Architectures: Views and Beyond (p. 6)</h4>
		  <h3>Más o menos podemos mapear comportamiento con requisitos funcionales y calidad con no funcionales</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1_NoTitle">
          <h2>Esto es lo <strong>mínimo</strong> que se nos puede exigir: que el sistema que desarrollemos cumpla los requisitos que nos han establecido (comportamiento y calidad, funcionales y no funcionales)</h2>
          <h3>Y que se termine en plazo y presupuesto (triángulo de hierro), pero ese es un tema para otro momento</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Decisiones de diseño</h1>
          <h2>Tomamos decisiones de diseño para cumplir los requisitos de nuestros usuarios y clientes</h2>
          <h3>Y si somos buenos profesionales, para satisfacer las necesidades, presentes y futuras, de los desarrolladores</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Decisiones de diseño</h1>
          <h2>Diseño arquitectural: decisiones para que el sistema alcance los objetivos marcados (comportamiento, calidad). Diseño no arquitectural: lo demás</h2>
          <h4>Clements, P., Bachmann, F., Bass, L., Garlan, D., Ivers, J., Little, R., Merson, P., Nord, R., and Stafford, J. Documenting Software Architectures: Views and Beyond (p. 6)</h4>
          <h3>Distinguimos diseño arquitectural del no arquitectural por si las decisiones afectan a todo el sistema o no (por su alcance), pero <strong>por nada más</strong></h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Decisiones de diseño</h1>
          <h2>Para diseñar un sistema hay que tomar muchas decisiones sobre el mismo: algunas afectarán a todo el sistema (y a esas las llamamos arquitecturales), otras a partes del mismo (por ejemplo a un módulo) y otras a partes pequeñas (por ejemplo a una única función). Pero <strong>todas son decisiones de diseño</strong></h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1_NoTitle">
          <h2>¿De diseño, o de implementación?</h2>
          <h3>La separación entre diseño e implementación cada vez está más cuestionada (<em>The Agile Manifesto</em> se escribe en Febrero de 2001)</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1><em>Code as Design: Three Essays by Jack W. Reeves</em></h1>
          <h2>El primer artículo se publicó en 1992, y luego una revisión del mismo en 2005</h2>
          <h2>Tenéis las referencias al final de la presentación. <strong>Leedlos</strong></h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1><em>Code as Design: Three Essays by Jack W. Reeves</em></h1>
          <h2>"In software engineering, we desperately need good design at all levels. In particular, we need good top level design..."</h2>
          <h2>"...these tools and notations are not a software design. Eventually, we have to create the real software design, and it will be in some programming language... we should not be afraid to code our designs as we derive them."</h2>
          <h2>"I am not arguing that we should not 'do design'... I simply insist that you have not completed the process until you have written and tested the code."</h2>
          <h2>"The source code may be the master design document, but it is seldom the only one necessary."</h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Patrones de diseño y estilos arquitecturales</h1>
          <h2>Patrones y estilos son <strong>medios</strong> para ayudarnos a crear buenos sistemas (con buenos diseños), no son <strong>fines</strong> en sí mismos</h2>
          <h3>Podemos tener una arquitectura llena de patrones y estilos conocidos y que aún así sea muy mala (p.ej. si el sistema no cumple sus requisitos)</h3>
          <h2>La aplicación adecuada de patrones de diseño y estilos arquitecturales es una técnica (aunque no la única) para ayudarnos a crear buenos diseños y arquitecturas</h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1_NoTitle">
          <h2>Un patrón de diseño o estilo arquitectural que no se refleje de alguna forma en el código de nuestro sistema no será parte de la arquitectura del mismo</h2>
          <h3>Aunque es posible que no podamos deducir a partir del código algunos de los patrones y estilos que se han aplicado, y por qué se han aplicado. Esa es una buena razón para crear y mantener documentación arquitectural</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>¿Construcción de software?</h1>
          <h2>Plantear que el desarrollo de software es análogo a la construcción de edificios (el arquitecto crea los planos y los albañiles construyen el edificio) fue una mala elección y hoy en día ya no resulta útil</h2>
          <h3><strong>El software no se construye</strong> (ni se fabrica), <strong>se diseña</strong> (la construcción, si nos empeñamos en mantener la analogía, es automática gracias al compilador)</h3>
          <h3>Las casas no cambian sustancialmente una vez se han construido, ni en general pueden usarse hasta que están terminadas. El software cambia, y se usa, tras cada lanzamiento (hoy en día pueden ser diarios)</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>¿Construcción de software?</h1>            
          <figure>
            <img src="assets/VideoSoftEngThumbnail.png">
            <figcaption> 
            <a href="https://youtu.be/zDEpeWQHtFU" target="_blank">
            Real Software Engineering, by Glenn Vanderburg
            </a>
            </figcaption>
          </figure>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Resulta que no era así...</h1>            
          <figure>
            <img src="assets/VideoSoftEngThumbnail2.png">
            <figcaption>                        
            <p style="text-align:right">
            (c) 2015, Glenn Vanderburg
            </p>
            </figcaption>
          </figure>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>...sino así</h1>            
          <figure>
            <img src="assets/VideoSoftEngThumbnail3.png">
            <figcaption>                        
            <p style="text-align:right">
            (c) 2015, Glenn Vanderburg
            </p>
            </figcaption>
          </figure>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>¿Jardinería de software?</h1>
          <h2>Que el desarrollo de software tiene más en común con la jardinería que con la construcción de edificios es un analogía atractiva</h2>
          <h3>Un jardín se diseña... hasta cierto nivel de detalle (no decides de antemano cuántas flores tiene que tener cada rosal)</h3>
          <h3>El jardín crece, evoluciona, y requiere un mantenimiento constante</h3>
          <h2>Nos podemos plantear que quizás el software se deba "cultivar", no construir</h2>
          <h3>No deja de ser una analogía, y por tanto hay que evitar llevarla demasiado lejos</h3>
        </section>
    	<section class="focalize-slide" data-slide-name="SimpleCitySlide1_NoTitle_Blueish">
          <h2>En arquitectura de paisajes hay un técnica de diseño evolutivo para construir caminos al aire libre: <em>Espera un año, mira por dónde transita la gente de forma natural y cuánta gente pasa. Después crea los caminos a lo largo de esas líneas, del ancho que haga falta</em></h2>
          <h2>El diseño surge de la demanda de los usuarios, no se impone a priori. Aunque esto sea de dudosa aplicación al diseño de productos [software], es una fuente de inspiración para el <strong>diseño ágil</strong></h2>
          <h2><strong>No como excusa para evitar un diseño cuidadoso, sino como inspiración para tener un diseño adaptable</strong></h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Entonces, ¿qué pasa con la arquitectura de software?</h1>
          <h2>La arquitectura es dinámica. Puede cambiar con cada línea de código añadida o quitada. Evoluciona conforme se programa</h2>
          <h2>Los diagramas y documentos no son el diseño real, el código fuente es el diseño real</h2>
          <h3>Esto no significa que todo lo que nos importa de la arquitectura se pueda deducir del código fuente (no se puede). Pero si que significa que da igual lo que pongamos en la documentación de la arquitectura si no refleja correctamente el sistema real</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Por lo tanto...</h1>
          <h2>Un arquitecto de software que no está en contacto con el código fuente no está en contacto con la arquitectura real</h2>
          <h3>Se les ha llamado "arquitectos de Power Point", "arquitectos de torre de marfil" o "arquitectos astronautas" (tan lejos del código que igual podrían estar en el espacio)</h3>
          <h2>Todos los programadores son arquitectos hasta cierto punto, quieran esa responsabilidad o no</h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1_NoTitle_Blueish">
          <h2>Si nuestra analogía es que el desarrollo de software es como la construcción de edificios...</h2>
          <h2>Si no se considera el código como la arquitectura real...</h2>
          <h2>Y si hay uno o más arquitectos de Power Point...</h2>
          <h2>La arquitectura va a <strong>degradarse con el tiempo</strong>, porque...</h2>
        </section>
      	<section class="focalize-slide" data-slide-name="SimpleCitySlide1_NoTitle_Blueish">
          <h2>…los arquitectos de Power Point no tocan el código y no pueden detectar cuándo este se degrada ni ayudar a corregir esta degradación</h2>
          <h3>Conforme más avanza el diseño menos influencia tienen sobre el mismo. Llega un punto en que los programadores ignoran a los arquitectos de Power Point, porque hace mucho tiempo que estos no saben casi nada sobre la arquitectura real del sistema</h3>
          <h2>...los arquitectos de Power Point pasan mucho tiempo creando diseños grandes y muy detallados</h2>
          <h3>Lo que resulta un desperdicio cuando hay que cambiarlos</h3>
          <h2>...los programadores no creen que la arquitectura sea su problema, y no le prestan atención (causando así aún más degradación)</h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Entonces, ¿diseñamos y documentamos la arquitectura o no?</h1>
          <h2>El diseño por adelantado y la documentación arquitectural están bien</h2>
          <h3>Discutir y evaluar alternativas, prever problemas, plantear líneas maestras</h3>
          <h3>Exponer razones, alternativas, restricciones que no se pueden deducir del código, es informativa para otros desarrolladores, de un nivel de abstracción más alto que el código y puede resaltar elementos importantes o complejos</h3>
          <h2>Siempre que recordemos que <strong>la arquitectura inicial puede mejorarse</strong></h2>
          <h2>Que la arquitectura inicial <strong>debe concretarse</strong></h2>
          <h2>Que los arquitectos tienen que <strong>tocar el código</strong></h2>
          <h2>Que el diseño debe ser <strong>ágil</strong></h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Entonces, ¿diseñamos y documentamos la arquitectura o no?</h1>
          <h2>Los modelos no son especificaciones. El código es el diseño real. Los diagramas son una inspiración, no una especificación</h2>
          <h3>La documentación completa de diseño se puede crear después de que el código se ha completado si hace falta para algo</h3>
          <h2>Todos los modelos tienen problemas. El diseño evolucionará conforme se programa y se aprende más del problema que estamos resolviendo y del sistema que estamos construyendo</h2>
          <h2>No podemos diseñar la arquitectura que queremos para nuestro sistema cuando esté "terminado", dentro de un año, si queremos lanzar la primera beta en dos meses y luego lanzar versión cada dos semanas</h2>
          <h2>La integridad arquitectural de un sistema requiere que todos los desarrolladores tengan ideas compatibles y coherentes: <strong>comunicación</strong></h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1_NoTitle_Blueish">
          <h2>Las metodologías ágiles consideran que tener una buena arquitectura es tan importante que todas las acciones de modelizado y programación durante la vida del software se consideran arquitectura, y <strong>todos</strong> los programadores son corresponsables de la arquitectura del sistema en el que trabajan</h2>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Modelizado cercano al código</h1>
          <h2>Algunas metodologías ágiles proponen minimizar/eliminar el modelizado, aunque otras son neutrales al respecto</h2>
          <h3>Y muchos desarrolladores que las usan lo encuentran imprescindible</h3>
          <h2>En general, las metodologías ágiles buscan proporcionar valor al usuario lo antes posible en forma de funcionalidades completamente implementadas</h2>
          <h3>Esto sugiere una aproximación "vertical" a la arquitectura: p.ej., diseñar en un sprint la parte de presentación, de dominio y de persistencia necesaria para alguna funcionalidad</h3>
          <h3>También es buena idea identificar y abordar cuanto antes la funcionalidad que puede ser complicada desde el punto de vista arquitectural</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
          <h1>Modelizado cercano al código</h1>
          <h2>Se puede ir del código al modelo, y del modelo al código, cuando sea necesario</h2>
          <h3>Cambias el nivel de abstracción conforme te hace falta durante el trabajo diario</h3>
          <h2>Para hacer esto los arquitectos de Power Point no sirven: el modelo ideal es el de <strong>arquitecto / "maestro programador"</strong></h2>
          <h3>Un diseñador experimentado pasará menos tiempo programando y más con tareas de nivel más alto. Pero no debe despegarse totalmente del código</h3>
          <h2>Evita el requisito de que alguien tenga que revisar y aprobar la arquitectura</h2>
          <h3>Si su aprobación es tan importante, debería participar en el diseño y aprovechar para instruir al equipo</h3>
        </section>
        <section class="focalize-slide" data-slide-name="SimpleCitySlide1">
        <h1>Bibliografía y lecturas sugeridas</h1>
        <h2><a href="http://www.craiglarman.com/wiki/index.php?title=Book_-_Practices_for_Scaling_Lean_and_Agile"
        target="_blank">Craig Larman & Bas Vodde. Practices for Scaling Lean & Agile Development</a> (ch. 8, design & architecture)</h2>
        <h2><a href="http://www.sei.cmu.edu/library/abstracts/books/0321552687.cfm"
        target="_blank">Paul Clements et al. Documenting Software Architectures: Views and Beyond, 2nd Edition</a> (Prologue)</h2>
        <h2><a href="http://www.developerdotstar.com/mag/articles/reeves_design_main.html" target="_blank">Code as design: three essays by Jack W. Reeves</a></h2>
        <h2><a href="http://blog.codinghorror.com/it-came-from-planet-architecture/" target="_blank">Coding horror: it came from planet architecture</a></h2>
        <h2><a href="http://www.johndcook.com/blog/2008/10/27/why-there-will-always-be-programmers/" target="_blank">John D. Cook: why there will always be programmers</a></h2>
        <h2><a href="http://www.joelonsoftware.com/articles/fog0000000018.html" target="_blank">Joel on Software: don't let architecture astronauts scare you</a></h2>
        <h3>Esta presentación se ha creado con <a href="https://github.com/rbejar/Focalize.js" target="_blank">Focalize.js</a></h3>
        </section>
  </div>
</div>
</body>
</html>